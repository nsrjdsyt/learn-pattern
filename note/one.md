# 面向对象

## 设计原则
    5大设计原则：SOLID
    - S 单一职责原则
    - O 开放封闭原则
    - L 李氏置换原则
    - I 接口独立原则
    - D 依赖倒置原则


    unix/linux设计哲学：
    - 小既是美；
    - 让每个程序只做好一件事；
    - 快速建立原型；
    - 舍弃高效率而取可移植性；
    - 采用纯文本来存储数据；
    - 让每个程序都称为过滤器；
    - 允许用户定制环境；
    - 各部分之和大于整体；
    - 寻求90%的解决方案；


## 设计模式
    23种设计模式：
    - 创建型
        * 工厂模式（工厂方法模式、抽象工厂模式、建造者模式）
        * 单例模式
        * 原型模式

    - 结构型
        * 适配器模式
        * 装饰器模式
        * 代理模式
        * 外观模式
        * 桥接模式
        * 组合模式
        * 享元模式

    - 行为型
        * 策略模式
        * 模板方法模式
        * 观察者模式
        * 迭代器模式
        * 职责链模式
        * 命令模式
        * 备忘录模式
        * 状态模式
        * 访问者模式
        * 中介者模式
        * 解释器模式


## 常用模式       

工厂模式：
 - 将new操作单独封装
 - 遇到new时，就要考虑是否该使用工厂模式
场景：
  - jquery - $('div')
  - React.createElement
  - Vue 异步组件

单例模式：
- 系统中被唯一使用
- 一个类只有一个实例
场景：
  - jquery 只有一个 $
  - vuex和redux的store

适配器模式：
- 旧接口格式和使用者不兼容
- 中间加一个适配器转换接口
场景：
  - 封装旧接口
  - vue computed属性

装饰器模式：
- 为对象添加新功能
- 不改变其原有的结构和功能
场景：
  - es7 装饰器
  - core-decorators 第三方库:https://www.npmjs.com/package/core-decorators


代理模式：
- 使用者无权访问目标对象
- 中间加代理，通过代理做授权和控制
场景：
  - 网页事件代理
  - jquery $.proxy
  - es6 proxy

代理模式vs适配器模式
- 适配器模式：提供一个不同的接口
- 代理模式：提供一模一样的接口

代理模式vs装饰器模式
- 适配器模式：显示原有功能，但是经过限制或者阉割之后的
- 装饰器模式：扩展功能，原有功能不变且可直接使用


外观模式：
- 为子系统中的一组接口提供了一个高层接口
- 使用者使用这个高层接口


观察者模式：
- 发布&订阅
- 一对多
场景：
- 网页事件绑定
- Promise.then().then()
- jQuery $.Callbacks
- nodejs 自定义事件 require('events').EventEmitter
- vue 和 react 组件生命周期触发
- vue 的 watch

迭代器模式：
- 顺序访问一个集合
- 使用者无需知道集合的内部结构（封装）
场景：
- jquery each
- es6 Iterator


状态模式：
- 一个对象有状态变化
- 每次状态变化都会触发一个逻辑
- 不能总是用if else 来控制


原型模式：
- clone自己，生成一个新对象
场景：
- Object.create